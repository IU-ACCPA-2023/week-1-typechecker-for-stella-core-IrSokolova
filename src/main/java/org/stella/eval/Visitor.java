// File generated by the BNF Converter (bnfc 2.9.4.1).

package org.stella.eval;

import java.lang.Integer;
import java.util.ArrayList;

import com.ibm.icu.impl.Pair;
import org.syntax.stella.Absyn.AProgram;
import org.syntax.stella.Absyn.SomeReturnType;
import org.syntax.stella.Absyn.TypeNat;
import org.syntax.stella.Absyn.Var;

/*** Visitor Design Pattern Skeleton. ***/

/* This implements the common visitor design pattern.
   Tests show it to be slightly less efficient than the
   instanceof method, but easier to use.
   Replace the R and A parameters with the desired return
   and context types.*/

public class Visitor
{
  AProgram program;
  public Visitor(AProgram program){
    ProgramVisitor<Integer,Integer> programVisitor = new ProgramVisitor<>();
    programVisitor.visit(program, new ArrayList<Pair<String, String>>());
  }

  public class ProgramVisitor<R, List> implements org.syntax.stella.Absyn.Program.Visitor<Integer, ArrayList<Pair<String, String>>>
  {
    public Integer visit(AProgram p, ArrayList<Pair<String, String>> arg)
    { /* Code for AProgram goes here */
      p.languagedecl_.accept(new LanguageDeclVisitor<Integer, ArrayList<Pair<String, String>>>(), arg);
      for (org.syntax.stella.Absyn.Extension x: p.listextension_) {
        x.accept(new ExtensionVisitor<Integer, ArrayList<Pair<String, String>>>(), arg);
      }

      for (org.syntax.stella.Absyn.Decl x: p.listdecl_) {
        x.accept(new DeclVisitor<Integer, ArrayList<Pair<String, String>>>(), arg);
//        Deletes local variables
        arg.clear();
      }
      return null;
    }
  }
  public class LanguageDeclVisitor<R, List> implements org.syntax.stella.Absyn.LanguageDecl.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.LanguageCore p, ArrayList<Pair<String, String>> arg)
    { /* Code for LanguageCore goes here */
      return null;
    }
  }
  public class ExtensionVisitor<R, List> implements org.syntax.stella.Absyn.Extension.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.AnExtension p, ArrayList<Pair<String, String>> arg)
    { /* Code for AnExtension goes here */
      for (String x: p.listextensionname_) {
        //x;
      }
      return null;
    }
  }
  public class DeclVisitor<R, List> implements org.syntax.stella.Absyn.Decl.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.DeclFun p, ArrayList<Pair<String, String>> arg)
    { /* Code for DeclFun goes here */
      for (org.syntax.stella.Absyn.Annotation x: p.listannotation_) {
        x.accept(new AnnotationVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      }

//      Checks for the shadowing variable
      for (org.syntax.stella.Absyn.ParamDecl x: p.listparamdecl_) {
        Pair<String,String> newParam = x.accept(new ParamDeclVisitor<R, ArrayList<Pair<String, String>>>(), arg);
          for (Pair<String,String> pair: arg) {
              if (pair.first.equals(newParam.first)){
                  System.out.println("TYPE ERROR");
                  System.out.println("Shadowing of variable");
                  System.exit(1);
              }
          }
        arg.add(newParam);
      }
      p.returntype_.accept(new ReturnTypeVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.throwtype_.accept(new ThrowTypeVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      for (org.syntax.stella.Absyn.Decl x: p.listdecl_) {
        x.accept(new DeclVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      }
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.DeclTypeAlias p, ArrayList<Pair<String, String>> arg)
    { /* Code for DeclTypeAlias goes here */
      //p.stellaident_;
      p.type_.accept(new TypeVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
  }
  public class LocalDeclVisitor<R, List> implements org.syntax.stella.Absyn.LocalDecl.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.ALocalDecl p, ArrayList<Pair<String, String>> arg)
    { /* Code for ALocalDecl goes here */
      p.decl_.accept(new DeclVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
  }
  public class AnnotationVisitor<R, List> implements org.syntax.stella.Absyn.Annotation.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.InlineAnnotation p, ArrayList<Pair<String, String>> arg)
    { /* Code for InlineAnnotation goes here */
      return null;
    }
  }
  public class ParamDeclVisitor<R, List> implements org.syntax.stella.Absyn.ParamDecl.Visitor<Pair<String, String>, ArrayList<Pair<String, String>>>
  {
    public Pair<String, String> visit(org.syntax.stella.Absyn.AParamDecl p, ArrayList<Pair<String, String>> arg)
    {
      p.type_.accept(new TypeVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return Pair.of(p.stellaident_, p.type_.toString());
    }
  }
  public class ReturnTypeVisitor<R, List> implements org.syntax.stella.Absyn.ReturnType.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.NoReturnType p, ArrayList<Pair<String, String>> arg)
    { /* Code for NoReturnType goes here */
      return null;
    }
    public R visit(org.syntax.stella.Absyn.SomeReturnType p, ArrayList<Pair<String, String>> arg)
    { /* Code for SomeReturnType goes here */
      p.type_.accept(new TypeVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
  }
  public class ThrowTypeVisitor<R,List> implements org.syntax.stella.Absyn.ThrowType.Visitor<R,ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.NoThrowType p, ArrayList<Pair<String, String>> arg)
    { /* Code for NoThrowType goes here */
      return null;
    }
    public R visit(org.syntax.stella.Absyn.SomeThrowType p, ArrayList<Pair<String, String>> arg)
    { /* Code for SomeThrowType goes here */
      for (org.syntax.stella.Absyn.Type x: p.listtype_) {
        x.accept(new TypeVisitor<R,ArrayList<Pair<String, String>>>(), arg);
      }
      return null;
    }
  }
  public class ExprVisitor<R, List> implements org.syntax.stella.Absyn.Expr.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.If p, ArrayList<Pair<String, String>> arg)
    {
//        Checks the expression under if for the correct type and if it exists
      if (p.expr_1.getClass().getName().contains("Var")){
        boolean varFound = false;
        for (Pair<String, String> pair: arg) {
          if (pair.first.equals(((Var) p.expr_1).stellaident_)){
            varFound = true;
            if (!isTypeBool(pair.second)){
              System.out.println("TYPE ERROR");
              System.out.println("The type of expression under if should be TypeBool but got " + pair.second);
              System.exit(1);
            }
          }
        }
        if (!varFound){
            System.out.println("TYPE ERROR");
            System.out.println("The variable " + ((Var) p.expr_1).stellaident_ + " wasn't found");
            System.exit(1);
        }
      } else if (!isTypeBool(p.expr_1)){
        System.out.println("TYPE ERROR");
        System.out.println("The type of expression under if should be TypeBool but got " + p.expr_1.getClass().getName());
        System.exit(1);
      }


//      Checks the same type for the expressions under then and else
      if (p.expr_2.getClass().getName().contains("Var") && p.expr_3.getClass().getName().contains("Var")){
        String typeExpr2 = "";
        String typeExpr3 = "";
        for (Pair<String, String> pair: arg) {
          if (pair.first.equals(((Var) p.expr_2).stellaident_)){
            typeExpr2 = pair.second;
          }
          if (pair.first.equals(((Var) p.expr_3).stellaident_)){
            typeExpr3 = pair.second;
          }
        }
        if (!haveSameType(typeExpr2, typeExpr3)){
          System.out.println("TYPE ERROR");
          System.out.println("Expressions under then and else should have the same type");
          System.exit(1);
        }
      } else if (p.expr_2.getClass().getName().contains("Var")) {
        String typeExpr2 = "";
        for (Pair<String, String> pair: arg) {
          if (pair.first.equals(((Var) p.expr_2).stellaident_)){
            typeExpr2 = pair.second;
          }
        }
        if (!haveSameType(typeExpr2, p.expr_3)){
          System.out.println("TYPE ERROR");
          System.out.println("Expressions under then and else should have the same type");
          System.exit(1);
        }
      } else if (p.expr_3.getClass().getName().contains("Var")) {
        String typeExpr3 = "";
        for (Pair<String, String> pair: arg) {
          if (pair.first.equals(((Var) p.expr_3).stellaident_)){
            typeExpr3 = pair.second;
          }
        }
        if (!haveSameType(typeExpr3, p.expr_2)){
          System.out.println("TYPE ERROR");
          System.out.println("Expressions under then and else should have the same type");
          System.exit(1);
        }
      } else if (!haveSameType(p.expr_2, p.expr_3)){
        System.out.println("TYPE ERROR");
        System.out.println("Expressions under then and else should have the same type");
        System.exit(1);
      }
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_3.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Let p, ArrayList<Pair<String, String>> arg)
    { /* Code for Let goes here */
      //p.stellaident_;
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.LessThan p, ArrayList<Pair<String, String>> arg)
    { /* Code for LessThan goes here */
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.LessThanOrEqual p, ArrayList<Pair<String, String>> arg)
    { /* Code for LessThanOrEqual goes here */
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.GreaterThan p, ArrayList<Pair<String, String>> arg)
    { /* Code for GreaterThan goes here */
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.GreaterThanOrEqual p, ArrayList<Pair<String, String>> arg)
    { /* Code for GreaterThanOrEqual goes here */
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Equal p, ArrayList<Pair<String, String>> arg)
    { /* Code for Equal goes here */
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.NotEqual p, ArrayList<Pair<String, String>> arg)
    { /* Code for NotEqual goes here */
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.TypeAsc p, ArrayList<Pair<String, String>> arg)
    { /* Code for TypeAsc goes here */
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.type_.accept(new TypeVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Abstraction p, ArrayList<Pair<String, String>> arg)
    { /* Code for Abstraction goes here */
      for (org.syntax.stella.Absyn.ParamDecl x: p.listparamdecl_) {
//          Checks for the shadowing of a variable
          Pair<String,String> newParam = x.accept(new ParamDeclVisitor<R, ArrayList<Pair<String, String>>>(), arg);
          for (Pair<String,String> pair: arg) {
              if (pair.first.equals(newParam.first)){
                  System.out.println("TYPE ERROR");
                  System.out.println("Shadowing of variable");
                  System.exit(1);
              }
          }
          arg.add(newParam);
      }
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Tuple p, ArrayList<Pair<String, String>> arg)
    { /* Code for Tuple goes here */
      for (org.syntax.stella.Absyn.Expr x: p.listexpr_) {
        x.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      }
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Record p, ArrayList<Pair<String, String>> arg)
    { /* Code for Record goes here */
      for (org.syntax.stella.Absyn.Binding x: p.listbinding_) {
        x.accept(new BindingVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      }
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Variant p, ArrayList<Pair<String, String>> arg)
    { /* Code for Variant goes here */
      //p.stellaident_;
      p.exprdata_.accept(new ExprDataVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Match p, ArrayList<Pair<String, String>> arg)
    { /* Code for Match goes here */
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      for (org.syntax.stella.Absyn.MatchCase x: p.listmatchcase_) {
        x.accept(new MatchCaseVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      }
      return null;
    }
    public R visit(org.syntax.stella.Absyn.List p, ArrayList<Pair<String, String>> arg)
    { /* Code for List goes here */
      for (org.syntax.stella.Absyn.Expr x: p.listexpr_) {
        x.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      }
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Add p, ArrayList<Pair<String, String>> arg)
    { /* Code for Add goes here */
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.LogicOr p, ArrayList<Pair<String, String>> arg)
    { /* Code for LogicOr goes here */
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Multiply p, ArrayList<Pair<String, String>> arg)
    { /* Code for Multiply goes here */
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.LogicAnd p, ArrayList<Pair<String, String>> arg)
    { /* Code for LogicAnd goes here */
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Application p, ArrayList<Pair<String, String>> arg)
    { /* Code for Application goes here */
      if (p.expr_.getClass().getName().contains("Var")){
              for (Pair<String, String> pair : arg) {
                  if (pair.first.equals(((Var) p.expr_).stellaident_)) {
                      if (!isFunction(pair.second)) {
                          System.out.println("TYPE ERROR");
                          System.out.println("Applied non-function " + pair.first);
                          System.exit(1);
                      }
                  }
              }
      } else if (!isFunction(p.expr_)) {
          System.out.println("TYPE ERROR");
          System.out.println("Applied non-function");
          System.exit(1);
      }
        p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      for (org.syntax.stella.Absyn.Expr x: p.listexpr_) {
        if (x.getClass().getName().contains("Var")){
            boolean varFound = false;
            for (Pair<String,String> pair: arg) {
                if (pair.first.equals(((Var) x).stellaident_)){
                    varFound = true;
                }
            }
            if (!varFound){
                System.out.println("TYPE ERROR");
                System.out.println("The variable " + ((Var) x).stellaident_ + " wasn't found");
                System.exit(1);
            }
        }
        x.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      }

      return null;
    }
    public R visit(org.syntax.stella.Absyn.ConsList p, ArrayList<Pair<String, String>> arg)
    { /* Code for ConsList goes here */
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Head p, ArrayList<Pair<String, String>> arg)
    { /* Code for Head goes here */
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.IsEmpty p, ArrayList<Pair<String, String>> arg)
    { /* Code for IsEmpty goes here */
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Tail p, ArrayList<Pair<String, String>> arg)
    { /* Code for Tail goes here */
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Succ p, ArrayList<Pair<String, String>> arg)
    { /* Code for Succ goes here */
        //Checks the expression under succ should have Type Nat
        if (p.expr_.getClass().getName().contains("Var")) {
            boolean varFound = false;
            for (Pair<String, String> pair : arg) {
                if (pair.first.equals(((Var) p.expr_).stellaident_)) {
                    varFound = true;
                    if (!isTypeNat(pair.second)) {
                        System.out.println("TYPE ERROR");
                        System.out.println("Expression under Succ should have type Nat ");
                        System.exit(1);
                    }
                }
            }
            if (!varFound){
                System.out.println("TYPE ERROR");
                System.out.println("The variable " + ((Var) p.expr_).stellaident_ + " wasn't found");
                System.exit(1);
            }
        } else if (!isTypeNat(p.expr_)){
            System.out.println("TYPE ERROR");
            System.out.println("Expression under Succ should have type Nat");
            System.exit(1);
        }
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.LogicNot p, ArrayList<Pair<String, String>> arg)
    { /* Code for LogicNot goes here */
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Pred p, ArrayList<Pair<String, String>> arg)
    { /* Code for Pred goes here */

      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.IsZero p, ArrayList<Pair<String, String>> arg)
    { /* Code for IsZero goes here */
        //Checks the expression under isZero should have Type Nat
      if (p.expr_.getClass().getName().contains("Var")) {
          for (Pair<String, String> pair : arg) {
              if (pair.first.equals(((Var) p.expr_).stellaident_)) {
                  if (!isTypeNat(pair.second)) {
                      System.out.println("TYPE ERROR");
                      System.out.println("\"Expression under isZero should have type Nat ");
                      System.exit(1);
                  }
              }
          }
      } else if (!isTypeNat(p.expr_)){
          System.out.println("TYPE ERROR");
          System.out.println("Expression under isZero should have type Nat");
          System.exit(1);
      }
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Fix p, ArrayList<Pair<String, String>> arg)
    { /* Code for Fix goes here */
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.NatRec p, ArrayList<Pair<String, String>> arg)
    { /* Code for NatRec goes here */
        if (p.expr_1.getClass().getName().contains("Var")) {
            for (Pair<String, String> pair : arg) {
                if (pair.first.equals(((Var) p.expr_1).stellaident_)) {
                    if (!isTypeNat(pair.second)) {
                        System.out.println("TYPE ERROR");
                        System.out.println("\"The first expression should have type Nat ");
                        System.exit(1);
                    }
                }
            }
        } else if (!isTypeNat(p.expr_1)){
            System.out.println("TYPE ERROR");
            System.out.println("The first expression should have type Nat");
            System.exit(1);
        }
      p.expr_1.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_2.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_3.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Fold p, ArrayList<Pair<String, String>> arg)
    { /* Code for Fold goes here */
      p.type_.accept(new TypeVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Unfold p, ArrayList<Pair<String, String>> arg)
    { /* Code for Unfold goes here */
      p.type_.accept(new TypeVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.DotRecord p, ArrayList<Pair<String, String>> arg)
    { /* Code for DotRecord goes here */
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      //p.stellaident_;
      return null;
    }
    public R visit(org.syntax.stella.Absyn.DotTuple p, ArrayList<Pair<String, String>> arg)
    { /* Code for DotTuple goes here */
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      //p.integer_;
      return null;
    }
    public R visit(org.syntax.stella.Absyn.ConstTrue p, ArrayList<Pair<String, String>> arg)
    { /* Code for ConstTrue goes here */
      return null;
    }
    public R visit(org.syntax.stella.Absyn.ConstFalse p, ArrayList<Pair<String, String>> arg)
    { /* Code for ConstFalse goes here */
      return null;
    }
    public R visit(org.syntax.stella.Absyn.ConstInt p, ArrayList<Pair<String, String>> arg)
    { /* Code for ConstInt goes here */
      //p.integer_;
      return null;
    }
    public R visit(org.syntax.stella.Absyn.Var p, ArrayList<Pair<String, String>> arg)
    { /* Code for Var goes here */
      //p.stellaident_;
      return null;
    }
  }
  public class MatchCaseVisitor<R, List> implements org.syntax.stella.Absyn.MatchCase.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.AMatchCase p, ArrayList<Pair<String, String>> arg)
    { /* Code for AMatchCase goes here */
      p.pattern_.accept(new PatternVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
  }
  public class OptionalTypingVisitor<R, List> implements org.syntax.stella.Absyn.OptionalTyping.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.NoTyping p, ArrayList<Pair<String, String>> arg)
    { /* Code for NoTyping goes here */
      return null;
    }
    public R visit(org.syntax.stella.Absyn.SomeTyping p, ArrayList<Pair<String, String>> arg)
    { /* Code for SomeTyping goes here */
      p.type_.accept(new TypeVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
  }
  public class PatternDataVisitor<R, List> implements org.syntax.stella.Absyn.PatternData.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.NoPatternData p, ArrayList<Pair<String, String>> arg)
    { /* Code for NoPatternData goes here */
      return null;
    }
    public R visit(org.syntax.stella.Absyn.SomePatternData p, ArrayList<Pair<String, String>> arg)
    { /* Code for SomePatternData goes here */
      p.pattern_.accept(new PatternVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
  }
  public class ExprDataVisitor<R, List> implements org.syntax.stella.Absyn.ExprData.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.NoExprData p, ArrayList<Pair<String, String>> arg)
    { /* Code for NoExprData goes here */
      return null;
    }
    public R visit(org.syntax.stella.Absyn.SomeExprData p, ArrayList<Pair<String, String>> arg)
    { /* Code for SomeExprData goes here */
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
  }
  public class PatternVisitor<R, List> implements org.syntax.stella.Absyn.Pattern.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.PatternVariant p, ArrayList<Pair<String, String>> arg)
    { /* Code for PatternVariant goes here */
      //p.stellaident_;
      p.patterndata_.accept(new PatternDataVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.PatternTuple p, ArrayList<Pair<String, String>> arg)
    { /* Code for PatternTuple goes here */
      for (org.syntax.stella.Absyn.Pattern x: p.listpattern_) {
        x.accept(new PatternVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      }
      return null;
    }
    public R visit(org.syntax.stella.Absyn.PatternRecord p, ArrayList<Pair<String, String>> arg)
    { /* Code for PatternRecord goes here */
      for (org.syntax.stella.Absyn.LabelledPattern x: p.listlabelledpattern_) {
        x.accept(new LabelledPatternVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      }
      return null;
    }
    public R visit(org.syntax.stella.Absyn.PatternList p, ArrayList<Pair<String, String>> arg)
    { /* Code for PatternList goes here */
      for (org.syntax.stella.Absyn.Pattern x: p.listpattern_) {
        x.accept(new PatternVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      }
      return null;
    }
    public R visit(org.syntax.stella.Absyn.PatternCons p, ArrayList<Pair<String, String>> arg)
    { /* Code for PatternCons goes here */
      p.pattern_1.accept(new PatternVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      p.pattern_2.accept(new PatternVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.PatternFalse p, ArrayList<Pair<String, String>> arg)
    { /* Code for PatternFalse goes here */
      return null;
    }
    public R visit(org.syntax.stella.Absyn.PatternTrue p, ArrayList<Pair<String, String>> arg)
    { /* Code for PatternTrue goes here */
      return null;
    }
    public R visit(org.syntax.stella.Absyn.PatternInt p, ArrayList<Pair<String, String>> arg)
    { /* Code for PatternInt goes here */
      //p.integer_;
      return null;
    }
    public R visit(org.syntax.stella.Absyn.PatternSucc p, ArrayList<Pair<String, String>> arg)
    { /* Code for PatternSucc goes here */

      p.pattern_.accept(new PatternVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public R visit(org.syntax.stella.Absyn.PatternVar p, ArrayList<Pair<String, String>> arg)
    { /* Code for PatternVar goes here */
      //p.stellaident_;
      return null;
    }
  }
  public class LabelledPatternVisitor<R, List> implements org.syntax.stella.Absyn.LabelledPattern.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.ALabelledPattern p, ArrayList<Pair<String, String>> arg)
    { /* Code for ALabelledPattern goes here */
      //p.stellaident_;
      p.pattern_.accept(new PatternVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
  }
  public class BindingVisitor<R, List> implements org.syntax.stella.Absyn.Binding.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.ABinding p, ArrayList<Pair<String, String>> arg)
    { /* Code for ABinding goes here */
      //p.stellaident_;
      p.expr_.accept(new ExprVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
  }
  public class TypeVisitor<R, List> implements org.syntax.stella.Absyn.Type.Visitor<Integer, ArrayList<Pair<String, String>>>
  {
    public Integer visit(org.syntax.stella.Absyn.TypeFun p, ArrayList<Pair<String, String>> arg)
    { /* Code for TypeFun goes here */
      for (org.syntax.stella.Absyn.Type x: p.listtype_) {
        x.accept(new TypeVisitor<Integer, ArrayList<Pair<String, String>>>(), arg);
      }
      p.type_.accept(new TypeVisitor<Integer, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public Integer visit(org.syntax.stella.Absyn.TypeRec p, ArrayList<Pair<String, String>> arg)
    { /* Code for TypeRec goes here */
      //p.stellaident_;
      p.type_.accept(new TypeVisitor<Integer, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public Integer visit(org.syntax.stella.Absyn.TypeSum p, ArrayList<Pair<String, String>> arg)
    { /* Code for TypeSum goes here */
      p.type_1.accept(new TypeVisitor<Integer, ArrayList<Pair<String, String>>>(), arg);
      p.type_2.accept(new TypeVisitor<Integer, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public Integer visit(org.syntax.stella.Absyn.TypeTuple p, ArrayList<Pair<String, String>> arg)
    { /* Code for TypeTuple goes here */
      for (org.syntax.stella.Absyn.Type x: p.listtype_) {
        x.accept(new TypeVisitor<Integer, ArrayList<Pair<String, String>>>(), arg);
      }
      return null;
    }
    public Integer visit(org.syntax.stella.Absyn.TypeRecord p, ArrayList<Pair<String, String>> arg)
    { /* Code for TypeRecord goes here */
      for (org.syntax.stella.Absyn.RecordFieldType x: p.listrecordfieldtype_) {
        x.accept(new RecordFieldTypeVisitor<Integer, ArrayList<Pair<String, String>>>(), arg);
      }
      return null;
    }
    public Integer visit(org.syntax.stella.Absyn.TypeVariant p, ArrayList<Pair<String, String>> arg)
    { /* Code for TypeVariant goes here */
      for (org.syntax.stella.Absyn.VariantFieldType x: p.listvariantfieldtype_) {
        x.accept(new VariantFieldTypeVisitor<Integer, ArrayList<Pair<String, String>>>(), arg);
      }
      return null;
    }
    public Integer visit(org.syntax.stella.Absyn.TypeList p, ArrayList<Pair<String, String>> arg)
    { /* Code for TypeList goes here */
      p.type_.accept(new TypeVisitor<Integer, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
    public Integer visit(org.syntax.stella.Absyn.TypeBool p, ArrayList<Pair<String, String>> arg)
    { /* Code for TypeBool goes here */
      return 0;
    }

    public Integer visit(TypeNat p, ArrayList<Pair<String, String>> arg)
    {
      return 0;
    }

    public Integer visit(org.syntax.stella.Absyn.TypeUnit p, ArrayList<Pair<String, String>> arg)
    { /* Code for TypeUnit goes here */
      return null;
    }
    public Integer visit(org.syntax.stella.Absyn.TypeVar p, ArrayList<Pair<String, String>> arg)
    { /* Code for TypeVar goes here */
      //p.stellaident_;
      return null;
    }
  }
  public class VariantFieldTypeVisitor<R, List> implements org.syntax.stella.Absyn.VariantFieldType.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.AVariantFieldType p, ArrayList<Pair<String, String>> arg)
    { /* Code for AVariantFieldType goes here */
      //p.stellaident_;
      p.optionaltyping_.accept(new OptionalTypingVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
  }
  public class RecordFieldTypeVisitor<R, List> implements org.syntax.stella.Absyn.RecordFieldType.Visitor<R, ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.ARecordFieldType p, ArrayList<Pair<String, String>> arg)
    { /* Code for ARecordFieldType goes here */
      //p.stellaident_;
      p.type_.accept(new TypeVisitor<R, ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
  }
  public class TypingVisitor<R,List> implements org.syntax.stella.Absyn.Typing.Visitor<R,ArrayList<Pair<String, String>>>
  {
    public R visit(org.syntax.stella.Absyn.ATyping p, ArrayList<Pair<String, String>> arg)
    { /* Code for ATyping goes here */
      p.expr_.accept(new ExprVisitor<R,ArrayList<Pair<String, String>>>(), arg);
      p.type_.accept(new TypeVisitor<R,ArrayList<Pair<String, String>>>(), arg);
      return null;
    }
  }

  public boolean isTypeBool(Object object){
    return (object.getClass().getName().contains("ConstTrue") || object.getClass().getName().contains("ConstFalse") || object.getClass().getName().contains("TypeBool") || object.getClass().getName().contains("Application") || object.getClass().getName().contains("IsZero"));
  }

  public boolean isTypeNat(Object object){
    return (object.getClass().getName().contains("ConstInt") || object.getClass().getName().contains("Succ") || object.getClass().getName().contains("TypeNat"));
  }

  public boolean isTypeBool(String str){
    return (str.contains("ConstTrue") || str.contains("ConstFalse") || str.contains("TypeBool") || str.contains("Application") || str.contains("IsZero"));
  }

  public boolean isTypeNat(String str){
    return (str.contains("ConstInt") || str.contains("Succ") || str.contains("TypeNat"));
  }
  public boolean haveSameType(Object a, Object b){
    return (isTypeNat(a) && isTypeNat(b) || isTypeBool(a) && isTypeBool(b));
  }

  public boolean haveSameType(String a, Object b){
    return (isTypeNat(a) && isTypeNat(b) || isTypeBool(a) && isTypeBool(b));
  }

  public boolean haveSameType(String a, String b){
    return (isTypeNat(a) && isTypeNat(b) || isTypeBool(a) && isTypeBool(b));
  }

  public boolean isFunction(Object a){
      return a.getClass().getName().contains("TypeFun") || a.getClass().getName().contains("Abstraction") ||  a.getClass().getName().contains("Application") ;
  }

    public boolean isFunction(String str){
        return str.contains("TypeFun") || str.contains("Abstraction") || str.contains("Application");
    }
}
